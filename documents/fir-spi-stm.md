# ASIC FPGA Prototyping - FIR Filter, SPI, STM32 Microcontroller

## Overview
In this lab you will be creating an SPI peripheral that will send and receive digital audio samples. These samples will be passed through a fir filter before being sent back and played. We will be using the STM32 development board from ECE 362 to capture and replay the audio.

## Required Materials
- Breadboard
- Jumper Wires
- 1 Aux cord
- Another Aux cord/Headphones

## Setup
To begin, open a terminal window, create a new directory, and move into it. Also, setup the directory structure and copy over the base makefile.

```bash
mkdir fir-spi
cd fir-spi
mkdir source
cp $TOOLSDIR/makefile .
```

Also, copy over your flex shift registers (both parallel and serial) from Lab 5, and all the FIR filter files from Lab 7.

## Create the STM32 Audio Input/Output Circuit
Follow the provided schematic to wire up the STM32 Audio input and output circuit. It is okay to use a TRS connector if you do not have a TRRS connector.

## Test A Simple Loopback

## Create A Simple SPI Peripheral
 In our implementation, we will use a 12-bit data size since all of our samples are 12-bits wide. This should help ensure we're able to process all the data in time.
 
 We'll also connect the NSS line so that we can sync with the data coming in.

## Test a Simple Loopback Through the DE2

## Add Audio Processing

For this lab we will be using SPI to interface between the STM32 Microcontroller and the DE2-115 Development Board.

In order to use SPI, we will need to have the following connections between our devices:

- SCK - This is the shared clock signal that is generated by the STM32.
- MOSI - This is the output from the controller (in our case the STM32), and the input to the peripheral (the DE2 in our case).
- MISO - This is the output from the peripheral and the input to the controller
- NSS - The inverted select signal. A device is selected if this line is low.

It's important to note that the two devices should share a ground connection in addition to the above signals, but since we are going to be powering the microcontroller from the DE2's USB port, we do not need to run a separate ground wire between the two devices.

Although we are using a select signal in this setup, we are simply just going to be using it to synchronize each data frame. Since there's only one device connected and we know all the data that is going to be sent, it is completely fine for us to not pay too much attention to the select line.

The overall data flow in this system is going to start at the audio in port. The audio will be provided by an external device via a 3.5mm jack. The STM32 will then sample the audio at 48kHz into 12-bit samples. These samples will then get sent to the DE2 over SPI. The DE2 will then either process the sample through the FIR filter, or simply loop the data back out the SPI (depending on the state of the mode switch). Lastly, the STM will convert the received sample back into an analog signal and we can listen to it using the audio out jack.

Fortunately, SPI is a very quick and simple protocol to implement. Essentially we can use two 12-bit shift registers and a counter to do most of the work for us.

However, in order to know when to clock our shift registers, we need to keep track of rising and falling edges of the sck signal. Let's begin by creating a module to synchronize and detect edges.

Module `sync_edge.sv`:

| signal | direction | width | description |
| :----: | :----: | :----: | :----: |
| clk | input | 1 bit | clock signal |
| n_rst | input | 1 bit | nReset signal |
| sck | input | 1 bit | The SPI clock signal |
| mosi | input | 1 bit | The incoming SPI data |
| nss | input | 1 bit | The incoming SPI select signal |
| nss_fall | output | 1 bit | 1 when a falling edge on nss has been detected |
| mosi_s | output | 1 bit | The synchronized MOSI signal |
| rise_edge | output | 1 bit | 1 when a rising edge of SCK has been detected |
| fall_edge | output | 1 bit | 1 when a falling edge of SCK has been detected |



Note: It will be necessary to obtain the `datapath` folder from the course staff. As long as it is named `datapath` and is in the same level as `source`, it will be added to the compilation.

Instructor note: add names to all combinational blocks/ generators to avoid compilation errors.
